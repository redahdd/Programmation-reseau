# Programmation-réseau 
Ce projet consiste en la réalisation d'un grand classique de la programmation réseau, un cas pratique de discussion instantanée de type client/serveur. A titre d'exemple, vous pouvez jeter un coup d'œil au protocole IRC (Internet Relay Chat) défini originellement par la RFC1459.

Le projet a pour objectif la réalisation d'une application de chat client/serveur en C permettant d'échanger des messages entre 2 utilisateurs, entre plusieurs utilisateurs, ou à destination de la totalité des utilisateurs connectés sur le réseau, ainsi que de s'envoyer des fichiers.
L'objectif sous-jacent de ce projet est la manipulation de l'API socket POSIX en C vue en cours, ainsi que la mise œuvre de communications sur TCP/IP.

####JALON 1####
Dans ce jalon, nous nous sommes concentrés sur la mise en œuvre d’un modèle client/serveur TCP en IPv4, dans lequel le serveur renvoie au client la chaîne de caractères que celui-ci lui a précédemment envoyée.
Nous avons commencé par développer la partie client. Le client crée une socket TCP en utilisant une adresse IPv4 et un numéro de port fournis en argument du programme. Il établit ensuite une connexion avec la socket du serveur. Une fois la connexion établie, le client peut envoyer des données au serveur et recevoir les réponses associées.
En parallèle, nous avons implémenté la partie serveur. Le serveur crée une socket TCP, la lie à un port d’écoute et se met en attente de nouvelles connexions entrantes. Lorsqu’une connexion est détectée, le serveur l’accepte et peut alors recevoir les données envoyées par le client.
Une fois la connexion établie, le client saisit une chaîne de caractères au clavier et l’envoie au serveur. Le serveur reçoit cette chaîne, puis la renvoie immédiatement au client. Enfin, le client affiche la chaîne reçue sur son écran, validant ainsi le bon fonctionnement de la communication client-serveur.
Afin de permettre la gestion de plusieurs clients simultanément, le serveur a été conçu pour fonctionner avec un unique processus. La gestion des différentes connexions clientes a été réalisée à l’aide de la fonction poll(), permettant de surveiller plusieurs descripteurs de fichiers en parallèle. Les informations relatives aux clients, notamment le descripteur de fichier de chaque socket cliente ainsi que l’adresse et le port associés, ont été stockées dans une liste chaînée maintenue par le serveur.
Du côté client, l’application a été développée de manière à pouvoir gérer simultanément les messages reçus depuis le serveur et les entrées saisies au clavier par l’utilisateur. Pour cela, la fonction poll() a également été utilisée afin de surveiller à la fois l’entrée standard du programme et la socket de communication avec le serveur. Cette approche permet au client de rester réactif sans bloquer l’exécution du programme.

####JALON 2####
L’objectif de ce jalon a été de permettre au serveur de récupérer, stocker et exploiter des informations relatives aux utilisateurs du service de messagerie instantanée. Contrairement au jalon 1, le serveur n’est plus un simple serveur répétitif : il joue désormais le rôle d’intermédiaire entre les utilisateurs pour l’échange de messages.
Grâce à cette évolution, les utilisateurs peuvent choisir un pseudo, consulter la liste des pseudos des utilisateurs connectés, récupérer des informations détaillées sur un utilisateur spécifique, envoyer des messages privés à un utilisateur donné et diffuser des messages globaux à l’ensemble des utilisateurs connectés.
Pour implémenter ces fonctionnalités, un système de commandes textuelles a été mis en place. Les utilisateurs saisissent des commandes spécifiques avant leur message (telles que /nick, /who, /whois <pseudo>, /msgall <msg> et /msg <pseudo> <msg>). Ces commandes sont interprétées par le client, puis transmises et traitées par le serveur, qui exécute l’action correspondante et assure la distribution appropriée des messages.
Ce jalon marque ainsi la transition vers une véritable application de messagerie instantanée multi-utilisateurs, avec une gestion structurée des identités et des communications.

